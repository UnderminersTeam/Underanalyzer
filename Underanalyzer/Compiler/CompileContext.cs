/*
  This Source Code Form is subject to the terms of the Mozilla Public
  License, v. 2.0. If a copy of the MPL was not distributed with this
  file, You can obtain one at https://mozilla.org/MPL/2.0/.
*/

using System;
using System.Collections.Generic;
using Underanalyzer.Compiler.Errors;
using Underanalyzer.Compiler.Lexer;
using Underanalyzer.Compiler.Parser;
using Underanalyzer.Compiler.Nodes;
using Underanalyzer.Compiler.Bytecode;

namespace Underanalyzer.Compiler;

/// <summary>
/// A compilation context belonging to a single code entry in a game.
/// </summary>
public sealed class CompileContext(string code, bool isGlobalScript, IGameContext gameContext)
{
    /// <summary>
    /// Source GML code being compiled.
    /// </summary>
    public string Code { get; } = code;

    /// <summary>
    /// Whether the code being compiled is for a global script or not.
    /// </summary>
    public bool IsGlobalScript { get; } = isGlobalScript;

    /// <summary>
    /// The game context this compile context belongs to.
    /// </summary>
    public IGameContext GameContext { get; } = gameContext;

    /// <summary>
    /// Macros declared by this code, or otherwise externally added.
    /// </summary>
    public Dictionary<string, Macro> Macros { get; } = new(4);

    /// <summary>
    /// Enums declared by this code, or otherwise externally added.
    /// </summary>
    public Dictionary<string, GMEnum> Enums { get; } = new(4);

    /// <summary>
    /// List of errors generated by this compile context.
    /// </summary>
    public List<ICompileError> Errors { get; } = new(4);

    /// <summary>
    /// List of instructions, set after produced by code generation.
    /// </summary>
    public List<IGMInstruction>? OutputInstructions { get; private set; } = null;

    /// <summary>
    /// List of sub-function entries, set after produced by code generation.
    /// </summary>
    public List<FunctionEntry>? OutputFunctionEntries { get; private set; } = null;

    // State tracking
    private bool _startedParse = false;
    private IASTNode? _parseRootNode = null;
    private FunctionScope? _parseRootScope = null;
    private HashSet<string>? _parseGlobalFunctions = null;
    private bool _startedCompile = false;
    private InstructionPatches _compilePatches;
    private bool _startedLink = false;

    /// <summary>
    /// Parses the GML code with the given game context.
    /// </summary>
    public void Parse()
    {
        // Ensure parse only occurs once
        if (_startedParse)
        {
            throw new InvalidOperationException("Code parse already started");
        }
        _startedParse = true;

        // Tokenize/lex code
        LexContext rootLexContext = new(this, Code);
        rootLexContext.Tokenize();

        // Exit if any errors occurred
        if (Errors.Count != 0)
        {
            return;
        }

        // Post-process tokens
        rootLexContext.PostProcessTokens();

        // Exit if any errors occurred
        if (Errors.Count != 0)
        {
            return;
        }

        // Parse tokens into tree
        ParseContext parseContext = new(this, rootLexContext.Tokens);
        parseContext.Parse();

        // Exit if any errors occurred
        if (Errors.Count != 0)
        {
            return;
        }

        // Post-process parse tree
        parseContext.PostProcessTree();

        // Exit if any errors occurred
        if (Errors.Count != 0)
        {
            return;
        }

        // Successful parse! Store results.
        _parseRootNode = parseContext.Root;
        _parseRootScope = parseContext.RootScope;
        _parseGlobalFunctions = parseContext.ParseGlobalFunctions;
    }

    /// <summary>
    /// Compiles the GML code with the given game context. Will re-use earlier parse results if available.
    /// </summary>
    public void Compile()
    {
        // Ensure compile only occurs once
        if (_startedCompile)
        {
            throw new InvalidOperationException("Code compile already started");
        }
        _startedCompile = true;

        // Parse code if not already done
        if (!_startedParse)
        {
            Parse();
        }
        if (_parseRootNode is null || _parseRootScope is null)
        {
            return;
        }

        // Generate bytecode
        BytecodeContext bytecodeContext = new(this, _parseRootNode, _parseRootScope, _parseGlobalFunctions);
        bytecodeContext.GenerateCode();

        // Exit if any errors occurred
        if (Errors.Count != 0)
        {
            return;
        }

        // Successful code generation! Store results.
        OutputInstructions = bytecodeContext.Instructions;
        OutputFunctionEntries = bytecodeContext.FunctionEntries;
        _compilePatches = bytecodeContext.Patches;

        // Remove references that we no longer need
        _parseRootNode = null;
        _parseRootScope = null;
        _parseGlobalFunctions = null;
    }

    /// <summary>
    /// Links resulting bytecode to data, if a successful compile was completed.
    /// </summary>
    /// <remarks>
    /// Before linking, if the code is a global script, all locally-declared global function names should be registered.
    /// This can be done by iterating over <see cref="OutputFunctionEntries"/>.
    /// </remarks>
    public void Link()
    {
        // Ensure link only occurs once
        if (_startedLink)
        {
            throw new InvalidOperationException("Code link already started");
        }
        _startedLink = true;

        // Ensure compile successfully finished
        if (!_startedCompile || OutputInstructions is null)
        {
            throw new InvalidOperationException("Code compile was not completed; linking may not occur");
        }

        // Post-process bytecode
        BytecodeContext.PatchInstructions(this, _compilePatches);

        // Remove references that we no longer need
        _compilePatches = default;
    }

    /// <summary>
    /// Pushes a lexer error to the list of errors generated for this compile context.
    /// </summary>
    internal void PushError(string message, LexContext lexContext, int textPosition)
    {
        Errors.Add(new LexerError(message, lexContext, textPosition));
    }

    /// <summary>
    /// Pushes a parser error to the list of errors generated for this compile context.
    /// </summary>
    internal void PushError(string message, IToken? nearbyToken = null)
    {
        Errors.Add(new ParserError(message, nearbyToken));
    }
}
